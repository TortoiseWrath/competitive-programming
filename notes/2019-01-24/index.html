<!DOCTYPE html>

<title>Competitive Programming - January 24, 2019</title>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="/notes/notes.css">

<header>
    <h1>Competitive Programming</h1>
    <time datetime="2019-01-24">January 24, 2019</time>
</header>

<article>
    <p>
    Reminder: when you google <strong>anything</strong> or refer to <strong>any</strong> documentation while solving a problem, post a link to the information that helped you in <strong>#compprogramming-docs</strong>, <strong>no matter how trivial</strong>. Weâ€™ll compile these links into printed documentation for competitions that do not allow Internet access.
    <h2>Updates</h2>
    <h3>Another competitive programming book</h3>
    <p class="lnum">In addition to <a href="https://cpbook.net"><i>Competitive Programming 3</i></a>, programming master Antti Laaksonen has recently published the <a href="https://cses.fi/book.pdf"><i>Competitive Programmer's Handbook</i></a>, a free 296-page ebook (more info at <a href="https://codeforces.com/blog/entry/50728">his blog post</a>), as well as an expanded version, the <a href="https://www.springer.com/us/book/9783319725468"><i>Guide to Competitive Programming</i></a> (ebook $39.99, softcover $49.99).
    <h3>More sites with practice problems</h3>
    <ul>
        <li><strong><a href="https://code-drills.com">Code Drills</a></strong> &ndash; Once you've completed some problems on <a href="https://codeforces.com" class="noprint">Codeforces</a>, <a href="https://codechef.com" class="noprint">CodeChef</a>, or <a href="https://www.spoj.com/problems/classical" class="noprint">Spoj</a>, enter your username(s) at Code Drills to be recommended new problems to solve based on the difficulty level of your previous solves! More info at <a href="https://codeforces.com/blog/entry/48991">Balajiganapathi's blog on Codeforces</a>.</li>
        <li><strong><a href="https://www.spoj.com/problems/classical/" data-href="https://spoj.com">Sphere Online Judge (Spoj)</a></strong> &ndash; Lots of problems with difficulty scores for both concept and implementation, and diverse language support.</li>
        <li><a href="https://cses.fi/problemset/">CSES Problem Set</a> &ndash; Problems with rankings for top 5 fastest and shortest programs &ndash; great for practicing your optimization and/or code golf. The usual languages are supported. <a href="https://cses.fi/register">Register at CSES</a> and log in to submit.</li>
        <li><a href="https://cses.fi/boi/list/">BOI Contest Collection</a> &ndash; Practice past problems from the Baltic Olympiad in Informatics, including a virtual contest option. <a href="https://cses.fi/register" class="noprint">Register at CSES</a> and log in to view problems and submit solutions.</li>
        <li><a href="https://cses.fi/ceoi/list/">CEOI Contest Collection</a> &ndash; Practice past problems from the Central European Olympiad in Informatics, including a virtual contest option. <a href="https://cses.fi/register" class="noprint">Register at CSES</a> and log in to view problems and submit solutions.</li>
        <li>The <a href="http://springcontest.cs.mercer.edu/">Mercer Spring Programming Contest</a> publishes their past solution sets. This is of particular interest to those of us competing there on <time datetime="2019-02-16">February 16</a>. We'll use the 2018 problems as practice at meetings in the coming weeks so don't do those!</li>
        <li><a href="https://community.topcoder.com/tc?module=ProblemArchive">Topcoder Problem Archive</a> &ndash; Problems from past Topcoder SRMs and TCO finals. Appears to be read-only. Also check their <a href="https://www.topcoder.com/?s=Editorials">post-contest editorials</a> for information on how to solve the problems!</li>
        <li><a href="https://codechef.com/INOIPRAC">INOI Practice Contest</a> &ndash; Practice problems for the Indian National Olympiad in Informatics hosted at CodeChef.</li>
        <li><a href="https://codechef.com/ZCOPRAC">ZCO Practice Contest</a> &ndash; Practice problems for the Zonal Computing Olympiad hosted at CodeChef.</li>
        <li><a href="https://contest.yandex.ru/ioi/">IOI Archive</a> &ndash; Past problems from the International Olympiad in Informatics hosted at Yandex Contest.</li>
    </ul>
    <h3>Upcoming competitions</h3>
    <ul>
        <li><strong>Happening now</strong> until <time datetime="2019-01-30T21:00:00.000-05:00"> Wednesday, January 30, 8:00 pm</time>: Topcoder Marathon Match 107</li>
        <li><time datetime="2019-01-26T08:00:00.000-06:00"><strong>Saturday, January 26</strong>, 8:00 am &ndash; 11:00 am</time>: <a href="https://www.codechef.com/LTIME68">CodeChef January Lunchtime 2019</a> (Individual, Online)</li>
        <li><time datetime="2019-01-26T12:00:00.000-05:00"><strong>Saturday, January 26</strong>, 11:00 am &ndash; 1:00 pm</time>: Topcoder SRM 748 (Individual, Online)</li>
        <li><time datetime="2019-01-31T06:30:00.000-06:00"><strong>Thursday, January 31</strong>, 6:30 am &ndash; 8:45 am</time>: <a href="https://codeforces.com/contests" class="noprint">Codeforces Round 535</a> (Individual, Online)</li>
        <li><time datetime="2019-02-16"><strong>Saturday, February 16</strong></time>: <a href="http://springcontest.cs.mercer.edu/" class="noprint">Mercer Spring Programming Contest</a> (Macon, GA, teams of 3) &ndash; <strong>three weeks away!</strong></li>
        <li><time datetime="2019-03-02T12:00:00.000-06:00"><strong>Saturday, March 2</strong>, noon &ndash; 5:00 pm</time>: <a href="http://naipc.uchicago.edu">North American Invitational Programming Contest</a> (Online, teams of 3)</li>
    </ul>

    <h2>Problems for this week</h2>
    <ul>
        <li><strong>Easy</strong>: Codeforces Problem 1097A (from Hello 2019) &ndash; <a href="https://codeforces.com/problemset/problem/1097/A" class="noprint">Gennady and a Card Game</a></li>
        <li><strong>Medium</strong>: Codeforces Problem 1105B (from Round 533) &ndash; <a href="https://codeforces.com/problemset/problem/1105/B" class="noprint">Zuhair and Strings</a></li>
        <li><strong>Hard</strong>: Codeforces Problem 774F (from VK Cup 2017) &ndash; <a href="https://codeforces.com/problemset/problem/774/F" class="noprint">Pens and Days of Week</a></li>
    </ul>

	<h2>Gennady and a Card Game</h2>
	<h3>Simplified problem description</h3>
	<p>Six standard playing cards are given. Each card is two characters: the first is the rank in <code>{'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'}</code> and the second is the suit in <code>{'D', 'C', 'S', 'H'}</code>.
	<p>If any of the last five cards have the same rank or suit as the first card, print <code>"YES"</code>. Otherwise, print <code>"NO"</code>.
	<h3>Solutions</h3>
	<p>Since the algorithm for this one is pretty straightforward, I've implemented it in a few different languages to demonstrate the difference in runtimes that can become very significant for more complex problems:
	<p><strong>C++</strong>: <a href="/solutions/1097a.cpp">1097a.cpp</a> &ndash; this solution runs in <strong class="lnum">0.28 ms</strong> on my system and <span class="lnum">30 ms</span> (which seems to be the minimum with overhead) in Codeforces' environment.
	<pre>#include <iostream>
#include &lt;string&gt;

int main() {
    std::string tableCard;
    std::cin &gt;&gt; tableCard;
    for(int i = 0; i &lt; 5; i++) {
        std::string card;
        std::cin &gt;&gt; card;
        if(card[0] == tableCard[0] || card[1] == tableCard[1]) {
            std::cout &lt;&lt; "YES\n";
            return 0;
        }
    }
    std::cout &lt;&lt; "NO\n";
    return 0;
}</pre>
	<p><strong>C</strong>: <a href="/solutions/1097a.c">1097a.c</a> &ndash; this solution runs in <strong class="lnum">0.48 ms</strong> on my system and <span class="lnum">30 ms</span> in Codeforces' environment.
	<pre>#include &lt;stdio.h&gt;

int main() {
    char tableCard[2];
    scanf("%2s", tableCard);
    char card[2];
    for(int i = 0; i &lt; 5; i++) {
        scanf("%2s", card);
        if(card[0] == tableCard[0] || card[1] == tableCard[1]) {
            puts("YES");
            return 0;
        }
    }
    puts("NO");
    return 0;
}</pre>
	<p><strong>Python 3</strong>: <a href="/solutions/1097a.py">1097a.py</a> &ndash; this solution runs in <strong class="lnum">12.3 ms</strong> on my system and <strong class="lnum">109 ms</strong> in Codeforces' environment.
	<pre>tableCard = input()
cards = input().split(' ')
for card in cards:
    if card[0] == tableCard[0] or card[1] == tableCard[1]:
        print("YES")
        exit()
print("NO")</pre>
	<p><strong>Java</strong>: <a href="/solutions/Cardgame.java">Cardgame.java</a> &ndash; this solution runs in <strong class="lnum">80.6 ms</strong> on my system and <strong class="lnum">124 ms</strong> in Codeforces' environment.
	<pre>import java.util.Scanner;

public class Cardgame {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String tableCard = scanner.nextLine();
        String[] myCards = scanner.nextLine().split(" ");
        for(String card : myCards) {
            if(card.charAt(0) == tableCard.charAt(0) || card.charAt(1) == tableCard.charAt(1)) {
                System.out.println("YES");
                scanner.close();
                System.exit(0);
            }
        }
        System.out.println("NO");
        scanner.close();
        System.exit(0);
    }
}</pre>
	<p><strong>Brainfuck</strong> See <a href="/solutions/1097a.bf">1097a.bf</a> for an annotated version. This solution runs in <strong class="lnum">0.26 ms</strong> on my system&mdash;sometimes C/C++ aren't the fastest languages! If there's a language supported by the contest in which you're participating that offers a more efficient way to implement your solution, and you're comfortable enough with the language to do so, by all means use it over another language!
	<pre>&gt;,&gt;,&lt;&lt;+++++&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++++[&gt;+++++++++++++&lt;-]&gt;[&gt;+&gt;+&gt;+&gt;+&gt;+&lt;&lt;&lt;&lt;&lt;-]+&gt;+++++++++++++++ +++++++++&gt;++++&gt;++++++++++++++++++&gt;+++++++++++++&gt;++++++++++++++&gt;++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;[-]&gt;[-]&lt;&lt;&lt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-]&lt;&lt;[&gt;&gt;+&gt;+&lt;&lt;&lt;-]&gt;&gt;&gt;[&lt;&lt;&lt;+&gt;&gt;&gt;-],,&gt;,&lt;[ &lt;&lt;-&gt;&gt;-]&gt;&gt;+&lt;&lt;&lt;&lt;[&gt;&gt;&gt;[&lt;&lt;-&gt;&gt;-]&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;&gt;&gt;-&lt;&lt;&lt;&lt;&lt;[&gt;&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;&lt;-]]&gt;&gt;&gt;&gt;&gt;&gt;[&lt;&lt;&lt;&lt;&lt;&lt;+&gt;&gt; &gt;&gt;&gt;&gt;-]&lt;[&gt;&gt;&gt;.&gt;.&gt;.&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;-&lt;&lt;&lt;&lt;[&gt;&gt;&gt;&gt;&gt;+&lt;&lt;&lt;&lt;&lt;-]]&gt;&gt;&gt;&gt;&gt;[ &lt;&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;&gt;-]&lt;[&gt;&gt;&gt;&gt;&gt;.&gt;.&gt;.&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;[-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;-]&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;[ &gt;&gt;&gt;&gt;.&gt;.&gt;.&lt;&lt;&lt;&lt;&lt;&lt;-]</pre>
	<h3>An object-oriented solution</h3>
	<p>Conventionally, better style would be to write something like the following (<a href="/solutions/1097a-oo.cpp">1097a-oo.cpp</a>):
	<pre>#include &lt;iostream&gt;

class Card {
public:
    bool operator==(const Card&amp; c) {
        return rank == c.rank || suit == c.suit;
    }
    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Card&amp; c) {
        in &gt;&gt; c.rank &gt;&gt; c.suit;
    }
private:
    char rank, suit;
};

int main() {
    Card tableCard;
    std::cin &gt;&gt; tableCard;
    for(int i = 0; i &lt; 5; i++) {
        Card card;
        std::cin &gt;&gt; card;
        if(card == tableCard) {
            std::cout &lt;&lt; "YES\n";
            return 0;
        }
    }
    std::cout &lt;&lt; "NO\n";amp;
    return 0;
}
</pre>
	<p>But this is <strong>not good for competitive programming</strong>! It takes longer to write, there is more that can go wrong, and it takes about 28% longer to run (<span class="lnum">0.36 ms</span> on my system)! Remember, you aren't scored on style&mdash;only on how long it takes you to submit a solution that runs within the time and memory limits.

	<h2>Zuhair and Strings</h2>
	<h3>Using brute force</h3>
	<p>The strings are guaranteed to match <code>^[a-z]+$</code>, so there are only 26 possible characters that could yield the largest <i>x</i>. Furthermore, the string can be a maximum of 20,000 characters in length. This means that there are at most 520,000 possible combinations of character and starting position for a substring. Perhaps simply checking the string like this (<a href="/solutions/1105b-brute.cpp">1105b-brute.cpp</a>) will be good enough:
	<pre>#include &lt;iostream&gt;
#include &lt;string&gt;

using std::cin;
using std::cout;
using std::string;

int main() {
    int n, k;
    string s;
    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
    int level = 0;
    for(int i = 0; i &lt; 26; i++) {
        char c = 'a' + i;
        string sub = "";
        for(int x = 0; x &lt; k; x++) {
            sub += c;
        }
        int charLevel = 0;
        for(int j = 0; j &lt;= n - k * level + 1; j++) {
            int start = j;
            while(start &lt;= n - k * (level + 1) + 1) {
                if(s.substr(start, k) == sub) {
                    start += k;
                    charLevel++;
                }
                else {
                    start++;
                }
            }
            if(charLevel &gt; level) level = charLevel;
            charLevel = 0;
        }
    }
    cout &lt;&lt; level &lt;&lt; '\n';
}
</pre>
	<p>Unfortunately, when given <a href="strings.in">a particularly troubling input</a> (generated with <a href="strings.py">strings.py</a>), this program takes <strong class="lnum">8.25 seconds</strong> to complete on my system&mdash;well over the 1-second time limit.

    <h2>Pens and Days of Week</h2>

    <h3>Simplified problem description</h3>
    <p class="lnum">Provided is an array <code>a</code> of <code>n</code> integers.
    <br>Every day <code>x</code> (starting from day 0), <code>a[x % n] -= 1</code>, except when <code>x % 7 == 6</code>.
    <br>What is the index of the first value in <code>a</code> to reach 0?
    <br>1 &le; <code>n</code> &le; 50,000; 1 &le; <code>a[i]</code> &le; 10&#x2079;</code>
    <br>Input format: <code>n</code> on first line, then space-separated <code>a[i]</code> on second line.
    <br>Output format: The index of the solution plus 1 (since the problem uses a 1-indexed array of pens).
    <br>Time limit: 3 seconds; memory limit: 256 MB.

    <h3>Na&iuml;ve solution</h3>
    <p>At first, this problem may appear easy. It is tempting to write something like the following (<a href="/solutions/pens-naive.cpp">pens-naive.cpp</a>):
    <pre>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    int n;
    std::vector&lt;int&gt; a;
    std::cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        int val;
        std::cin &gt;&gt; val;
        a.push_back(val);
    }
    int x = 0;
    while(true) {
        if(x % 7 != 6) a[x % n]--;
        if(a[x % n] == 0) {
            std::cout &lt;&lt; x % n + 1 &lt;&lt; std::endl;
            break;
        }
        x++;
    }
    return 0;
}</pre>

	<p><strong>This isn't good enough.</strong> Though this program should always produce the correct answer, it is not nearly efficient enough to process the maximum input. For the two sample cases, it completes in 2 ms on my system&mdash;pretty good, right?&mdash;but when given the <a href="pens.in">maximal input file</a> (50,000 pens each with 1,000,000,000 ml of ink; input file generated with <a href="pens.py">pens.py</a>), it segfaulted because <code>x</code> did not have enough bytes. After changing <code>x</code> to an <code>unsigned long long int</code> and adding some signal handling (see: <a href="pens-naive-modified.cpp">pens-naive-modified.cpp</a>), I estimated based on the <a href="pens.1h">state after one hour</a> that this algorithm would complete on my system in <strong class="lnum">10 days, 13 hours, and 18 minutes</strong>.

	<p>That is more than three seconds.

	<h3>Analyzing the problem</h3>
	<p>At this point, I made tables to show the state of the array in the na&iuml;ve solution after each day for each sample input:
	<div style="position: relative; width: 100%; text-align: right;">
		<div style="float: left; max-width: 50%;">
			<table style="margin-top: 0; margin-left: 0;">
				<thead>
					<tr><th rowspan="2">Sample 1</th><th>Pen 1</th><th>Pen 2</th><th>Pen 3</th></tr>
					<tr><th style="border: none;"><code>a[0]</code></th><th><code>a[1]</code></th><th><code>a[2]</code></th></tr>
				</thead>
				<tbody>
					<tr><th>Start</td><td>3</td><td>3</td><td>3</td></tr>
					<tr><th>After day 0</th><td class="highlight">2</td><td>3</td><td>3</td></tr>
					<tr><th>After day 1</th><td>2</td><td class="highlight">2</td><td>3</td></tr>
					<tr><th>After day 2</th><td>2</td><td>2</td><td class="highlight">2</td></tr>
					<tr><th>After day 3</th><td class="highlight">1</td><td>2</td><td>2</td></tr>
					<tr><th>After day 4</th><td>1</td><td class="highlight">1</td><td>2</td></tr>
					<tr><th>After day 5</th><td>1</td><td>1</td><td class="highlight">1</td></tr>
					<tr><th><strong>After day 6</strong></th><td class="highlight">1</td><td>1</td><td>1</td></tr>
					<tr><th>After day 7</th><td>1</td><td class="highlight"><strong>0</strong></td><td>1</td></tr>
				</tbody>
			</table>
			<p style="font-style: italic; text-align: left;">In these tables, the value that is decremented on each day is highlighted; days on which this value is <strong>not</strong> decremented (Sundays) are listed in bold in the left column. The first value equal to zero is bolded. Days are zero-indexed as in the above implementation despite being one-indexed in the problem statement; both indices are presented for the pen numbers in the header rows.
		</div>
		<div style="display: inline-block; max-width: 50%;">
			<table style="margin-top: 0; margin-right: 0;">
				<thead>
					<tr><th rowspan="2">Sample 2</th><th>Pen 1</th><th>Pen 2</th><th>Pen 3</th><th>Pen 4</th><th>Pen 5</th></tr>
					<tr><th style="border: none;"><code>a[0]</code></th><th><code>a[1]</code></th><th><code>a[2]</code></th><th><code>a[3]</code></th><th><code>a[4]</code></th></tr>
				</thead>
				<tbody>
					<tr><th>Start</td><td>5</td><td>4</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 0</th><td class="highlight">4</td><td>4</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 1</th><td>4</td><td class="highlight">3</td><td>5</td><td>4</td><td>4</td></tr>
					<tr><th>After day 2</th><td>4</td><td>3</td><td class="highlight">4</td><td>4</td><td>4</td></tr>
					<tr><th>After day 3</th><td>4</td><td>3</td><td>4</td><td class="highlight">3</td><td>4</td></tr>
					<tr><th>After day 4</th><td>4</td><td>3</td><td>4</td><td>3</td><td class="highlight">3</td></tr>
					<tr><th>After day 5</th><td class="highlight">3</td><td>3</td><td>4</td><td>3</td><td>3</td></tr>
					<tr><th><strong>After day 6</strong></th><td>3</td><td class="highlight">3</td><td>4</td><td>3</td><td>3</td></tr>
					<tr><th>After day 7</th><td>3</td><td>3</td><td class="highlight">3</td><td>3</td><td>3</td></tr>
					<tr><th>After day 8</th><td>3</td><td>3</td><td>3</td><td class="highlight">2</td><td>3</td></tr>
					<tr><th>After day 9</th><td>3</td><td>3</td><td>3</td><td>2</td><td class="highlight">2</td></tr>
					<tr><th>After day 10</th><td class="highlight">2</td><td>3</td><td>3</td><td>2</td><td>2</td></tr>
					<tr><th>After day 11</th><td>2</td><td class="highlight">2</td><td>3</td><td>2</td><td>2</td></tr>
					<tr><th>After day 12</th><td>2</td><td>2</td><td class="highlight">2</td><td>2</td><td>2</td></tr>
					<tr><th><strong>After day 13</strong></th><td>2</td><td>2</td><td>2</td><td class="highlight">2</td><td>2</td></tr>
					<tr><th>After day 14</th><td>2</td><td>2</td><td>2</td><td>2</td><td class="highlight">1</td></tr>
					<tr><th>After day 15</th><td class="highlight">1</td><td>2</td><td>2</td><td>2</td><td>1</td></tr>
					<tr><th>After day 16</th><td>1</td><td class="highlight">1</td><td>2</td><td>2</td><td>1</td></tr>
					<tr><th>After day 17</th><td>1</td><td>1</td><td class="highlight">1</td><td>2</td><td>1</td></tr>
					<tr><th>After day 18</th><td>1</td><td>1</td><td>1</td><td class="highlight">1</td><td>1</td></tr>
					<tr><th>After day 19</th><td>1</td><td>1</td><td>1</td><td>1</td><td class="highlight"><strong>0</strong></td></tr>
				</tbody>
			</table>
		</div>
	</div>

	<p><strong>Tip: Always try to calculate the sample inputs on paper to make sure you understand the problem correctly!</strong> You may even stumble into an efficient solution in the process. I spent some time at last week's meeting trying to figure out why my program wasn't working before realizing my algorithm was based on an incorrect interpretation of the problem statement.

	<p>After completing the above tables, I noticed that the pattern in the ink values was more obvious for each pen than for each day. Take pen 4 in sample 2, for instance. It starts with 4 ml of ink. This is then decremented on day 5<i>n</i> + 3 (n âˆˆ <b>Z</b>), except when <code>day % 7 == 6</code>. The following algorithm (<a href="/solutions/pens-vertical.cpp">pens-vertical.cpp</a>) naturally arises from this observation:

<pre>#include &lt;iostream&gt;
#include &lt;climits&gt;

int main() {
    int n;
    unsigned long long int minDay = ULLONG_MAX;
    int minPen = 0;
    std::cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++) {
        int ink;
        std::cin &gt;&gt; ink;

        unsigned long long int day = i;
        for(;;) {
            if(day % 7 == 6) {
                day += n;
                if(day % 7 == 6) {
                    break; // pen is never used
                }
            }
            ink--;
            if(day &gt;= minDay) {
                break; // pen is not the first to run out of ink
            }
            if(!ink) {
                minDay = day;
                minPen = i;
                break; // pen ran out of ink
            }
            day += n;
        }
    }
    std::cout &lt;&lt; minPen + 1 &lt;&lt; '\n';
    return 0;
}</pre>

	<p>Guess what? <strong>This isn't good enough either.</strong> If it is billions of days before a pen runs out of ink, there are still millions of calculations to be done on each pen. I again <a href="pens-vertical-modified.cpp">modified this program</a> to report the <a href="pens-vert.1h">state after one hour</a> and used this data to estimate that this program would complete in <strong class="lnum">22 hours and 15 minutes</strong> on my system&mdash;much faster than the first algorithm, but still more than 3 seconds.

	<h3>Optimizing the above algorithm</h3>
	<p>This algorithm certainly <em>feels</em> nicer than the first one (to me, anyway)&mdash;the calculations it's doing are much more straightforward, but there are still too many of them.
	<p>How can we determine the day on which each pen runs out of ink mathematically rather than with brute force?

	<h3>Another idea</h3>
	<p>What if we combined days into blocks such that each pen's ink is decreased by the same amount in each row of the table?

	[table]

	<p>This would make it very easy to determine how many rows of the table are needed before each pen runs out of ink. But how do we know which pen runs out of ink first if two pens now run out in the same row (block of days)?

	<p>The width of this table is lcm(7, n). A full LCM implementation is not needed&mdash;not only because one is <a href="https://en.cppreference.com/w/cpp/numeric/lcm" class="lnum">included in C++17</a>, but because lcm of a prime (7) and a variable integer can be simplified to:

<pre>int lcm7(int x) {
    return x % 7 ? x * 7 : x;
}</pre>
</article>
